const origListeners = __.DEBUG && new WeakMap();

if (__.MV3) {
  global.browser = chrome;
  if (__.DEBUG) addEventLogger();
} else if (__.BUILD !== 'firefox' && !global.browser?.runtime) {
  /* Auto-promisifier with a fallback to direct call on signature error.
     The fallback isn't used now since we call all synchronous methods via `chrome` */
  const directEvents = ['addListener', 'removeListener', 'hasListener', 'hasListeners'];
  // generated by tools/chrome-api-no-cb.js
  const directMethods = {
    alarms: ['create'],
    extension: ['getBackgroundPage', 'getExtensionTabs', 'getURL', 'getViews', 'setUpdateUrlData'],
    i18n: ['getMessage', 'getUILanguage'],
    identity: ['getRedirectURL'],
    runtime: ['connect', 'connectNative', 'getManifest', 'getURL', 'reload', 'restart'],
    tabs: ['connect'],
  };
  const promisify = function (fn, ...args) {
    let res;
    let resolve, reject;
    // Saving the local callstack before making an async call
    const localErr = new Error();
    try {
      args.push((...results) => {
        const {lastError} = chrome.runtime;
        if (lastError) {
          localErr.message = lastError.message;
          reject(localErr);
        } else {
          /* Some callbacks have 2 parameters so we're resolving as an array in that case.
             For example, chrome.runtime.requestUpdateCheck and chrome.webRequest.onAuthRequired */
          resolve(results.length <= 1 ? results[0] : results);
        }
      });
      fn.apply(this, args);
      res = new Promise((...rr) => ([resolve, reject] = rr));
    } catch (err) {
      if (!err.message.includes('No matching signature')) {
        throw err;
      }
      args.pop();
      res = fn.apply(this, args);
    }
    return res;
  };
  const proxify = (src, srcName, target, key) => {
    let res = src[key];
    if (res && typeof res === 'object') {
      res = createProxy(res, key);
    } else if (typeof res === 'function' && key.endsWith('Listener') && __.DEBUG) {
      res = patchEventListener(src, key, res);
    } else if (typeof res === 'function') {
      res = (srcName.startsWith('on') ? directEvents : directMethods[srcName] || []).includes(key)
        ? res.bind(src)
        : promisify.bind(src, res);
    }
    target[key] = res;
    return res;
  };
  const createProxy = (src, srcName) =>
    new Proxy({}, {
      get(target, key) {
        return target[key] || proxify(src, srcName, target, key);
      },
    });
  global.browser = createProxy(chrome);
} else if (__.DEBUG) {
  addEventLogger();
}

if (!__.MV3 && !DOMTokenList.prototype.replace) {
  // TODO: remove when minimum_chrome_version >= 61
  global.URLSearchParams = class extends URLSearchParams {
    constructor(init) {
      if (init && typeof init === 'object') {
        super();
        for (const [key, val] of init[Symbol.iterator] ? init : Object.entries(init)) {
          this.set(key, val);
        }
      } else {
        super(...arguments);
      }
    }
  };
}

function addEventLogger() {
  const patched = new WeakSet();
  const handler = {
    get(obj, k) {
      let val = obj[k];
      if (val && typeof val === 'object' && !patched.has(val)) {
        patched.add(val);
        let hasEvents, evt, fn;
        for (k in val) {
          if (k.startsWith('on') && (evt = val[k]) && typeof evt === 'object') {
            for (const ke in evt) {
              if (ke.endsWith('Listener') && typeof (fn = evt[ke]) === 'function') {
                evt[ke] = patchEventListener(evt, k, fn);
              }
            }
            hasEvents = true;
          }
        }
        if (!hasEvents) val = new Proxy(val, handler);
      }
      return val;
    },
  };
  if (chrome === browser) {
    global.chrome = global.browser = new Proxy(chrome, handler);
  } else {
    global.chrome = new Proxy(chrome, handler);
    global.browser = new Proxy(browser, handler);
  }
}

function patchEventListener(obj, name, fn) {
  let res = fn;
  switch (fn.name) {
    case 'addListener':
      res = (cb, ...opts) =>
        fn.call(obj, (...args) => {
          console.log(name, ...name === 'onMessage' ? args.slice(0, 2) : args);
          return cb(...args);
        }, ...opts);
      origListeners.set(fn, res);
      break;
    case 'removeListener':
      res = cb => {
        fn.call(obj, origListeners.get(cb));
        origListeners.delete(cb);
      };
      break;
    case 'hasListener':
      res = cb => fn.call(obj, origListeners.get(cb));
      break;
  }
  return res;
}
